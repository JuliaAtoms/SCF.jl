<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Self-Consistent Iteration · SCF.jl</title><link rel="canonical" href="juliaatoms.org/self_consistent_iteration/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><script src="../assets/latex.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">SCF.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../quantum_systems/">Quantum Systems</a></li><li><a class="tocitem" href="../fock_operators/">Fock Operators</a></li><li class="is-active"><a class="tocitem" href>Self-Consistent Iteration</a><ul class="internal"><li><a class="tocitem" href="#KrylovWrapper"><span>KrylovWrapper</span></a></li><li><a class="tocitem" href="#Gershgorin&#39;s-circle-theorem"><span>Gershgorin&#39;s circle theorem</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Self-Consistent Iteration</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Self-Consistent Iteration</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaAtoms/SCF.jl/blob/master/docs/src/self_consistent_iteration.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Self-Consistent-Iteration"><a class="docs-heading-anchor" href="#Self-Consistent-Iteration">Self-Consistent Iteration</a><a id="Self-Consistent-Iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Self-Consistent-Iteration" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="SCF.scf!" href="#SCF.scf!"><code>SCF.scf!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">scf!([fun!, ]fock[; ω=0, max_iter=200, tol=1e-8, verbosity=1])</code></pre><p>Perform the SCF iterations for the <code>fock</code> operator. One iteration is performed by <a href="#SCF.scf_iteration!"><code>scf_iteration!</code></a>. The optional <code>fun!(P̃,c̃)</code> argument allows for extra operations to be performed every SCF cycle (such as plotting, etc).</p><p><code>ω</code> is a relaxation parameter; the orbitals and mixing coefficients are updated as <code>wᵢ₊₁ = (1-ω)w̃ + ωwᵢ</code> where <code>w̃</code> is the solution in the current iteration and <code>wᵢ</code> the previous solution. The default (<code>ω=0</code>) is to only use this solution. A larger value of <code>ω</code> makes it easier to achieve convergence in oscillatory problems, but a too large value decreases the convergence rate. It is therefore desireable to reduce the value of <code>ω</code> if the convergence is deemed to be monotonous, the criterion for which is whether the change over the <code>monotonous_window</code> last iterations is steadily decreasing. If this is the case, <code>ω</code> will be reduced by multiplying by <code>ωfactor</code>. Conversely, if the change is non-monotonous, <code>ω</code> will be increased, but not beyond <code>ωmax</code>.</p><p>The SCF procedure continues until either the amount of iterations equals <code>max_iter</code> or the change in the coefficients is below <code>tol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/SCF.jl/blob/adc9cc1bfd299178bd1fd9ff7875b7e30310fe29/src/self_consistent_iteration.jl#L28-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SCF.scf_iteration!" href="#SCF.scf_iteration!"><code>SCF.scf_iteration!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">scf_iteration!(fock, P, H, c, okws,
               [; verbosity=0, method=:arnoldi, σ=nothing, tol=1e-10,
                update_mixing_coefficients=true])</code></pre><p>Perform one step of the SCF iteration. This will</p><ol><li><p>Improve each of the orbitals in turn, using the values of the orbitals <code>P</code> and mixing coefficients <code>c</code> from the previous step as input.</p></li><li><p>Solve the secular problem to find new values for the mixing coefficients, <code>c</code>, unless <code>update_mixing_coefficients==false</code>.</p></li></ol><p><code>okws</code> is a vector of <a href="@ref"><code>OrthogonalKrylovWrapper</code></a>s, one for each orbital.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/SCF.jl/blob/adc9cc1bfd299178bd1fd9ff7875b7e30310fe29/src/self_consistent_iteration.jl#L196-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SCF.solve_orbital_equation!" href="#SCF.solve_orbital_equation!"><code>SCF.solve_orbital_equation!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">solve_orbital_equation!(Pj, okw, method, tol)</code></pre><p>Solve the orbital equation for the <code>j</code>th orbital, by solving the eigenproblem of the <a href="@ref"><code>OrthogonalKrylovWrapper</code></a> operator <code>okw</code>, and store the result in the radial orbital vector of expansion coefficients <code>Pj</code>. The solution is computed using <code>method</code>; valid choices are</p><ol><li><p><code>:arnoldi</code>, which uses ArnoldiMethod.jl. Really small grid spacings/large grid extents can be problematic with this method, due to high condition numbers.</p></li><li><p><code>:lobpcg</code>, which uses IterativeSolvers.jl. Too coarse grids can cause never-ending loops or errors from the Cholesky decomposition, complaining about non-positive definite subproblems.</p></li></ol><p>Both methods are controlled by the stopping tolerance <code>tol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/SCF.jl/blob/adc9cc1bfd299178bd1fd9ff7875b7e30310fe29/src/solve_orbital_equation.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SCF.solve_secular_problem!" href="#SCF.solve_secular_problem!"><code>SCF.solve_secular_problem!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">solve_secular_problem!(H, c, fock)</code></pre><p>Form the energy matrix, store it in <code>H</code>, and then solve the secular problem <code>Hc = Ec</code> for the lowest eigenvalue.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/SCF.jl/blob/adc9cc1bfd299178bd1fd9ff7875b7e30310fe29/src/secular_problem.jl#L1-L6">source</a></section></article><h2 id="KrylovWrapper"><a class="docs-heading-anchor" href="#KrylovWrapper">KrylovWrapper</a><a id="KrylovWrapper-1"></a><a class="docs-heading-anchor-permalink" href="#KrylovWrapper" title="Permalink"></a></h2><p>The orbital improvements are performed via diagonalization of the integro-differential equations for each orbital. The diagonalization procedure is the Arnoldi method, which requires the repeated action of the Hamiltonian on a vector. The <a href="#SCF.KrylovWrapper"><code>KrylovWrapper</code></a> object is used to wrap Hamiltonians which are not simple <code>&lt;:AbstractMatrix</code> objects, but which require a specialized implementation of <a href="@ref"><code>mul!</code></a> to act on a <code>&lt;:AbstractVector</code> of coefficients. An example is the kind of Hamiltonians implemented in the <a href="https://github.com/JuliaAtoms/Atoms.jl">Atoms.jl</a> library, which are based on the function space algebra from <a href="https://github.com/JuliaApproximation/ContinuumArrays.jl">ContinuumArrays.jl</a>.</p><article class="docstring"><header><a class="docstring-binding" id="SCF.KrylovWrapper" href="#SCF.KrylovWrapper"><code>SCF.KrylovWrapper</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">KrylovWrapper(hamiltonian)</code></pre><p>Proxy object used in the Krylov iterations, during orbital improvement. This is useful, since <code>hamiltonian</code> may be defined to act on objects such as vectors living in function spaces (as e.g. implemented using ContinuumArrays.jl), whereas the SCF iterations act on the coefficients directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/SCF.jl/blob/adc9cc1bfd299178bd1fd9ff7875b7e30310fe29/src/krylov_wrapper.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{SCF.KrylovWrapper}" href="#Base.size-Tuple{SCF.KrylovWrapper}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">size(::KrylovWrapper)</code></pre><p>Returns the dimension of the <code>KrylovWrapper</code>. For Hamiltonians which are not <code>&lt;:AbstractMatrix</code>, this needs to be overloaded.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/SCF.jl/blob/adc9cc1bfd299178bd1fd9ff7875b7e30310fe29/src/krylov_wrapper.jl#L16-L21">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>LinearAlgebra.mul!(y::V₁, A::KrylovWrapper{T,Hamiltonian}, x::V₂) where {V₁,V₂,T,Hamiltonian&lt;:AbstractMatrix}</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Gershgorin&#39;s-circle-theorem"><a class="docs-heading-anchor" href="#Gershgorin&#39;s-circle-theorem">Gershgorin&#39;s circle theorem</a><a id="Gershgorin&#39;s-circle-theorem-1"></a><a class="docs-heading-anchor-permalink" href="#Gershgorin&#39;s-circle-theorem" title="Permalink"></a></h2><p><a href="https://en.wikipedia.org/wiki/Gershgorin_circle_theorem">Gershgorin&#39;s circle theorem</a> can be used to estimate the bounds on the eigenspectrum of a matrix. It is always correct, but only a useful estimate when the matrix is diagonally dominant. Furthermore, <a href="#SCF.gershgorin_bounds"><code>gershgorin_bounds</code></a> is limited to the case of Hermitian matrices, whose eigenvalues lie on the real line. If an experimental energy is known, that is almost always a better lower bound to use for the <a href="@ref">Shift-and-invert</a> strategy.</p><article class="docstring"><header><a class="docstring-binding" id="SCF.gershgorin_disc" href="#SCF.gershgorin_disc"><code>SCF.gershgorin_disc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gershgorin_disc(i, row)</code></pre><p>Return the <a href="https://en.wikipedia.org/wiki/Gershgorin_circle_theorem">Gershgorin disc</a> for the <code>i</code>th <code>row</code> of a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/SCF.jl/blob/adc9cc1bfd299178bd1fd9ff7875b7e30310fe29/src/gershgorin_discs.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SCF.gershgorin_discs" href="#SCF.gershgorin_discs"><code>SCF.gershgorin_discs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gershgorin_discs(A)</code></pre><p>Compute all <a href="https://en.wikipedia.org/wiki/Gershgorin_circle_theorem">Gershgorin discs</a> of a matrix <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/SCF.jl/blob/adc9cc1bfd299178bd1fd9ff7875b7e30310fe29/src/gershgorin_discs.jl#L13-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SCF.gershgorin_bounds" href="#SCF.gershgorin_bounds"><code>SCF.gershgorin_bounds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gershgorin_bounds(A)</code></pre><p>For a Hermitian matrix <code>A</code>, compute the bounds on the real axis of the eigenspectrum. NB that this bound will only be useful for diagonally dominant <code>A</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAtoms/SCF.jl/blob/adc9cc1bfd299178bd1fd9ff7875b7e30310fe29/src/gershgorin_discs.jl#L23-L29">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../fock_operators/">« Fock Operators</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 12 April 2021 11:42">Monday 12 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
