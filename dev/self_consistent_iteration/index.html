<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Self-Consistent Iteration · SCF</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script src="../assets/latex.js"></script></head><body><nav class="toc"><h1>SCF</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../quantum_systems/">Quantum Systems</a></li><li><a class="toctext" href="../fock_operators/">Fock Operators</a></li><li class="current"><a class="toctext" href>Self-Consistent Iteration</a><ul class="internal"><li><a class="toctext" href="#KrylovWrapper-1">KrylovWrapper</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Self-Consistent Iteration</a></li></ul><a class="edit-page" href="https://github.com/JuliaAtoms/SCF.jl/blob/master/docs/src/self_consistent_iteration.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Self-Consistent Iteration</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Self-Consistent-Iteration-1" href="#Self-Consistent-Iteration-1">Self-Consistent Iteration</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SCF.scf!" href="#SCF.scf!"><code>SCF.scf!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">scf!([fun!, ]fock[; ω=0, max_iter=200, tol=1e-8, verbosity=1])</code></pre><p>Perform the SCF iterations for the <code>fock</code> operator. One iteration is performed by <a href="#SCF.scf_iteration!"><code>scf_iteration!</code></a>. The optional <code>fun!(P̃,c̃)</code> argument allows for extra operations to be performed every SCF cycle (such as plotting, etc).</p><p><code>ω</code> is a relaxation parameter; the orbitals and mixing coefficients are updated as <code>wᵢ₊₁ = (1-ω)w̃ + ωwᵢ</code> where <code>w̃</code> is the solution in the current iteration and <code>wᵢ</code> the previous solution. The default (<code>ω=0</code>) is to only use this solution.</p><p>The SCF procedure continues until either the amount of iterations equals <code>max_iter</code> or the change in the coefficients is below <code>tol</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/SCF.jl/blob/15d5b540508efd6361a95c2b0ed5cfd8ec7a6651/src/self_consistent_iteration.jl#L1-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SCF.scf_iteration!" href="#SCF.scf_iteration!"><code>SCF.scf_iteration!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">scf_iteration!(fock, P, c[; verbosity=0, method=:arnoldi, tol=1e-10,
               update_mixing_coefficients=true])</code></pre><p>Perform one step of the SCF iteration. This will</p><ol><li><p>Improve each of the orbitals in turn, using the values of the orbitals <code>P</code> and mixing coefficients <code>c</code> from the previous step as input.</p></li><li><p>Solve the secular problem to find new values for the mixing coefficients, <code>c</code>, unless <code>update_mixing_coefficients==false</code>.</p></li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/SCF.jl/blob/15d5b540508efd6361a95c2b0ed5cfd8ec7a6651/src/self_consistent_iteration.jl#L123-L136">source</a></section><h2><a class="nav-anchor" id="KrylovWrapper-1" href="#KrylovWrapper-1">KrylovWrapper</a></h2><p>The orbital improvements are performed via diagonalization of the integro-differential equations for each orbital. The diagonalization procedure is the Arnoldi method, which requires the repeated action of the Hamiltonian on a vector. The <a href="#SCF.KrylovWrapper"><code>KrylovWrapper</code></a> object is used to wrap Hamiltonians which are not simple <code>&lt;:AbstractMatrix</code> objects, but which require a specialized implementation of <a href="#LinearAlgebra.mul!"><code>mul!</code></a> to act on a <code>&lt;:AbstractVector</code> of coefficients. An example is the kind of Hamiltonians implemented in the <a href="https://github.com/JuliaAtoms/Atoms.jl">Atoms.jl</a> library, which are based on the function space algebra from <a href="https://github.com/JuliaApproximation/ContinuumArrays.jl">ContinuumArrays.jl</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SCF.KrylovWrapper" href="#SCF.KrylovWrapper"><code>SCF.KrylovWrapper</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">KrylovWrapper(hamiltonian)</code></pre><p>Proxy object used in the Krylov iterations, during orbital improvement. This is useful, since <code>hamiltonian</code> may be defined to act on objects such as vectors living in function spaces (as e.g. implemented using ContinuumArrays.jl), whereas the SCF iterations act on the coefficients directly.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/SCF.jl/blob/15d5b540508efd6361a95c2b0ed5cfd8ec7a6651/src/krylov_wrapper.jl#L1-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.size-Tuple{SCF.KrylovWrapper}" href="#Base.size-Tuple{SCF.KrylovWrapper}"><code>Base.size</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">size(::KrylovWrapper)</code></pre><p>Returns the dimension of the <code>KrylovWrapper</code>. For Hamiltonians which are not <code>&lt;:AbstractMatrix</code>, this needs to be overloaded.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/SCF.jl/blob/15d5b540508efd6361a95c2b0ed5cfd8ec7a6651/src/krylov_wrapper.jl#L16-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.mul!" href="#LinearAlgebra.mul!"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">mul!(y, ::KrylovWrapper, x)</code></pre><p>Compute the action of the wrapped Hamiltonian on <code>x</code> and store it in <code>y</code>. For Hamiltonians which are not <code>&lt;:AbstractMatrix</code>, this needs to be overloaded.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/SCF.jl/blob/15d5b540508efd6361a95c2b0ed5cfd8ec7a6651/src/krylov_wrapper.jl#L25-L31">source</a></section><footer><hr/><a class="previous" href="../fock_operators/"><span class="direction">Previous</span><span class="title">Fock Operators</span></a></footer></article></body></html>
