<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Self-Consistent Iteration · SCF</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script src="../assets/latex.js"></script></head><body><nav class="toc"><h1>SCF</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../quantum_systems/">Quantum Systems</a></li><li><a class="toctext" href="../fock_operators/">Fock Operators</a></li><li class="current"><a class="toctext" href>Self-Consistent Iteration</a><ul class="internal"><li><a class="toctext" href="#KrylovWrapper-1">KrylovWrapper</a></li><li><a class="toctext" href="#Shift-and-invert-1">Shift-and-invert</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Self-Consistent Iteration</a></li></ul><a class="edit-page" href="https://github.com/JuliaAtoms/SCF.jl/blob/master/docs/src/self_consistent_iteration.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Self-Consistent Iteration</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Self-Consistent-Iteration-1" href="#Self-Consistent-Iteration-1">Self-Consistent Iteration</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SCF.scf!" href="#SCF.scf!"><code>SCF.scf!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">scf!([fun!, ]fock[; ω=0, max_iter=200, tol=1e-8, verbosity=1])</code></pre><p>Perform the SCF iterations for the <code>fock</code> operator. One iteration is performed by <a href="#SCF.scf_iteration!"><code>scf_iteration!</code></a>. The optional <code>fun!(P̃,c̃)</code> argument allows for extra operations to be performed every SCF cycle (such as plotting, etc).</p><p><code>ω</code> is a relaxation parameter; the orbitals and mixing coefficients are updated as <code>wᵢ₊₁ = (1-ω)w̃ + ωwᵢ</code> where <code>w̃</code> is the solution in the current iteration and <code>wᵢ</code> the previous solution. The default (<code>ω=0</code>) is to only use this solution. A larger value of <code>ω</code> makes it easier to achieve convergence in oscillatory problems, but a too large value decreases the convergence rate. It is therefore desireable to reduce the value of <code>ω</code> if the convergence is deemed to be monotonous, the criterion for which is whether the change over the <code>monotonous_window</code> last iterations is steadily decreasing. If this is the case, <code>ω</code> will be reduced by multiplying by <code>ωfactor</code>. Conversely, if the change is non-monotonous, <code>ω</code> will be increased, but not beyond <code>ωmax</code>.</p><p>The SCF procedure continues until either the amount of iterations equals <code>max_iter</code> or the change in the coefficients is below <code>tol</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/SCF.jl/blob/d2aedc7280a727405626e2f0ee6ec4d26067e53d/src/self_consistent_iteration.jl#L28-L50">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SCF.scf_iteration!" href="#SCF.scf_iteration!"><code>SCF.scf_iteration!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">scf_iteration!(fock, P, c[; verbosity=0, method=:arnoldi, σ=nothing, tol=1e-10,
               update_mixing_coefficients=true])</code></pre><p>Perform one step of the SCF iteration. This will</p><ol><li><p>Improve each of the orbitals in turn, using the values of the orbitals <code>P</code> and mixing coefficients <code>c</code> from the previous step as input.</p></li><li><p>Solve the secular problem to find new values for the mixing coefficients, <code>c</code>, unless <code>update_mixing_coefficients==false</code>.</p></li></ol></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/SCF.jl/blob/d2aedc7280a727405626e2f0ee6ec4d26067e53d/src/self_consistent_iteration.jl#L187-L200">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SCF.solve_orbital_equation!" href="#SCF.solve_orbital_equation!"><code>SCF.solve_orbital_equation!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">solve_orbital_equation!(Pj, eq, method, tol)</code></pre><p>Solve the orbital equation <code>eq</code> and store the result in the radial orbital vector of expansion coefficients <code>Pj</code>. The solution is computed using <code>method</code>; valid choices are</p><ol><li><p><code>:arnoldi</code>, which requires that <code>hamiltonian(eq)</code> supports <a href="#SCF.KrylovWrapper"><code>KrylovWrapper</code></a>, and</p></li><li><p><code>:arnoldi_shift_invert</code>, which iterates <code>(H-σ*I)⁻¹</code> and requires that <code>hamiltonian(eq)</code> supports <a href="#SCF.KrylovWrapper"><code>KrylovWrapper</code></a> <em>and</em> provides an overload for <code>MatrixFactorizations.preconditioner</code>. The shift is automatically chosen as <code>1.1ϵ</code> where <code>ϵ</code> is the (current estimate of the) orbital energy of the orbital governed by <code>eq</code>.</p></li></ol><p>Both methods are controlled by the stopping tolerance <code>tol</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/SCF.jl/blob/d2aedc7280a727405626e2f0ee6ec4d26067e53d/src/solve_orbital_equation.jl#L1-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SCF.solve_secular_problem!" href="#SCF.solve_secular_problem!"><code>SCF.solve_secular_problem!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">solve_secular_problem!(H, c, fock)</code></pre><p>Form the energy matrix, store it in <code>H</code>, and then solve the secular problem <code>Hc = Ec</code> for the lowest eigenvalue.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/SCF.jl/blob/d2aedc7280a727405626e2f0ee6ec4d26067e53d/src/secular_problem.jl#L1-L6">source</a></section><h2><a class="nav-anchor" id="KrylovWrapper-1" href="#KrylovWrapper-1">KrylovWrapper</a></h2><p>The orbital improvements are performed via diagonalization of the integro-differential equations for each orbital. The diagonalization procedure is the Arnoldi method, which requires the repeated action of the Hamiltonian on a vector. The <a href="#SCF.KrylovWrapper"><code>KrylovWrapper</code></a> object is used to wrap Hamiltonians which are not simple <code>&lt;:AbstractMatrix</code> objects, but which require a specialized implementation of <a href="#LinearAlgebra.mul!-Union{Tuple{Hamiltonian}, Tuple{T}, Tuple{V₂}, Tuple{V₁}, Tuple{V₁,KrylovWrapper{T,Hamiltonian},V₂}} where Hamiltonian&lt;:(AbstractArray{T,2} where T) where T where V₂ where V₁"><code>mul!</code></a> to act on a <code>&lt;:AbstractVector</code> of coefficients. An example is the kind of Hamiltonians implemented in the <a href="https://github.com/JuliaAtoms/Atoms.jl">Atoms.jl</a> library, which are based on the function space algebra from <a href="https://github.com/JuliaApproximation/ContinuumArrays.jl">ContinuumArrays.jl</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SCF.KrylovWrapper" href="#SCF.KrylovWrapper"><code>SCF.KrylovWrapper</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">KrylovWrapper(hamiltonian)</code></pre><p>Proxy object used in the Krylov iterations, during orbital improvement. This is useful, since <code>hamiltonian</code> may be defined to act on objects such as vectors living in function spaces (as e.g. implemented using ContinuumArrays.jl), whereas the SCF iterations act on the coefficients directly.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/SCF.jl/blob/d2aedc7280a727405626e2f0ee6ec4d26067e53d/src/krylov_wrapper.jl#L1-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.size-Tuple{SCF.KrylovWrapper}" href="#Base.size-Tuple{SCF.KrylovWrapper}"><code>Base.size</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">size(::KrylovWrapper)</code></pre><p>Returns the dimension of the <code>KrylovWrapper</code>. For Hamiltonians which are not <code>&lt;:AbstractMatrix</code>, this needs to be overloaded.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/SCF.jl/blob/d2aedc7280a727405626e2f0ee6ec4d26067e53d/src/krylov_wrapper.jl#L16-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.mul!-Union{Tuple{Hamiltonian}, Tuple{T}, Tuple{V₂}, Tuple{V₁}, Tuple{V₁,KrylovWrapper{T,Hamiltonian},V₂}} where Hamiltonian&lt;:(AbstractArray{T,2} where T) where T where V₂ where V₁" href="#LinearAlgebra.mul!-Union{Tuple{Hamiltonian}, Tuple{T}, Tuple{V₂}, Tuple{V₁}, Tuple{V₁,KrylovWrapper{T,Hamiltonian},V₂}} where Hamiltonian&lt;:(AbstractArray{T,2} where T) where T where V₂ where V₁"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">mul!(y, ::KrylovWrapper, x)</code></pre><p>Compute the action of the wrapped Hamiltonian on <code>x</code> and store it in <code>y</code>. For Hamiltonians which are not <code>&lt;:AbstractMatrix</code>, this needs to be overloaded.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/SCF.jl/blob/d2aedc7280a727405626e2f0ee6ec4d26067e53d/src/krylov_wrapper.jl#L31-L37">source</a></section><h2><a class="nav-anchor" id="Shift-and-invert-1" href="#Shift-and-invert-1">Shift-and-invert</a></h2><p>To improve the rate of convergence of the Krylov iterations, instead of computing the eigenvectors of <span>$\Hamiltonian$</span> when improving the orbitals, we can use the shift-and-invert strategy and instead iterate <span>$(\Hamiltonian-\sigma I)^{-1}$</span> with a shift <span>$\sigma$</span> that is located slightly below the target eigenvalue. The eigenvectors are shared between <span>$\Hamiltonian$</span> and <span>$(\Hamiltonian-\sigma I)^{-1}$</span>, but convergence towards the low-lying states is faster for <span>$(\Hamiltonian-\sigma I)^{-1}$</span>.</p><p>This approach is complicated by the fact that the orbital Hamiltonian <span>$\Hamiltonian$</span> is an integro-differential operator, which furthermore depends on the other orbitals through direct, exchange, and configuration interaction, and thus <span>$\Hamiltonian$</span> is not easily factorizable. However, we can compute the action of <span>$(\Hamiltonian-\sigma I)^{-1}$</span> using an <a href="https://github.com/JuliaMath/IterativeSolvers.jl">iterative solver</a> with a preconditioner constructed from all terms of <span>$\Hamiltonian$</span> except the integral operators (exchange interaction) and the source terms (configuration interaction). As mentioned in the documentation for <a href="#SCF.solve_orbital_equation!"><code>solve_orbital_equation!</code></a>, the orbital Hamiltonian must support <a href="#SCF.KrylovWrapper"><code>KrylovWrapper</code></a> as well as providing an overload for <a href="https://github.com/jagot/MatrixFactorizations.jl"><code>MatrixFactorizations.preconditioner</code></a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SCF.ShiftInvert" href="#SCF.ShiftInvert"><code>SCF.ShiftInvert</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ShiftInvert(A⁻¹, σ)</code></pre><p>Structure representing the inverse of a shifted matrix <code>Ã = A + σ*I</code>. This is used for finding eigenpairs of <code>Ã</code> in the neighbourhood of <code>σ</code>; useful in power methods such as the Krylov iteration, which converge the convex hull of the eigenspectrum first.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/SCF.jl/blob/d2aedc7280a727405626e2f0ee6ec4d26067e53d/src/shift_invert.jl#L1-L8">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SCF.ShiftInvert-Union{Tuple{M}, Tuple{T}, Tuple{M}, Tuple{M,T}} where T where M&lt;:(AbstractArray{T,2} where T)" href="#SCF.ShiftInvert-Union{Tuple{M}, Tuple{T}, Tuple{M}, Tuple{M,T}} where T where M&lt;:(AbstractArray{T,2} where T)"><code>SCF.ShiftInvert</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ShiftInvert(A[, σ])</code></pre><p>Construct the <a href="#SCF.ShiftInvert"><code>ShiftInvert</code></a> structure from the factorization of the matrix <code>A</code> shifted by <code>σ</code>. If no shift is specified, the lower bound as calculated by <a href="#SCF.gershgorin_bounds"><code>gershgorin_bounds</code></a> is used by default.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/SCF.jl/blob/d2aedc7280a727405626e2f0ee6ec4d26067e53d/src/shift_invert.jl#L26-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.mul!-Tuple{Any,ShiftInvert,Any}" href="#LinearAlgebra.mul!-Tuple{Any,ShiftInvert,Any}"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">mul!(y, si::ShiftInvert, x)</code></pre><p>Compute the action of the shifted-and-inverted matrix <code>si.A⁻¹</code> on <code>x</code> and store the result in <code>y</code>. It is assumed that the factorization does not depend on the initial contents of <code>y</code>; if that is not the case, an overload has to be provided.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/SCF.jl/blob/d2aedc7280a727405626e2f0ee6ec4d26067e53d/src/shift_invert.jl#L37-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.mul!-Tuple{Any,ShiftInvert{#s1,T} where T where #s1&lt;:MatrixFactorizations.IterativeFactorization,Any}" href="#LinearAlgebra.mul!-Tuple{Any,ShiftInvert{#s1,T} where T where #s1&lt;:MatrixFactorizations.IterativeFactorization,Any}"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">mul!(y, si::ShiftInvert{&lt;:IterativeFactorization}, x)</code></pre><p>Compute the action of the shifted-and-inverted matrix <code>si.A⁻¹</code> on <code>x</code> and store the result in <code>y</code> for factorizations based on <a href="https://github.com/JuliaMath/IterativeSolvers.jl">IterativeSolvers.jl</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/SCF.jl/blob/d2aedc7280a727405626e2f0ee6ec4d26067e53d/src/shift_invert.jl#L48-L54">source</a></section><h3><a class="nav-anchor" id="Gershgorin&#39;s-circle-theorem-1" href="#Gershgorin&#39;s-circle-theorem-1">Gershgorin&#39;s circle theorem</a></h3><p><a href="https://en.wikipedia.org/wiki/Gershgorin_circle_theorem">Gershgorin&#39;s circle theorem</a> can be used to estimate the bounds on the eigenspectrum of a matrix. It is always correct, but only a useful estimate when the matrix is diagonally dominant. Furthermore, <a href="#SCF.gershgorin_bounds"><code>gershgorin_bounds</code></a> is limited to the case of Hermitian matrices, whose eigenvalues lie on the real line. If an experimental energy is known, that is almost always a better lower bound to use for the <a href="#Shift-and-invert-1">Shift-and-invert</a> strategy.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SCF.gershgorin_disc" href="#SCF.gershgorin_disc"><code>SCF.gershgorin_disc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gershgorin_disc(i, row)</code></pre><p>Return the <a href="https://en.wikipedia.org/wiki/Gershgorin_circle_theorem">Gershgorin disc</a> for the <code>i</code>th <code>row</code> of a matrix.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/SCF.jl/blob/d2aedc7280a727405626e2f0ee6ec4d26067e53d/src/gershgorin_discs.jl#L1-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SCF.gershgorin_discs" href="#SCF.gershgorin_discs"><code>SCF.gershgorin_discs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gershgorin_discs(A)</code></pre><p>Compute all <a href="https://en.wikipedia.org/wiki/Gershgorin_circle_theorem">Gershgorin discs</a> of a matrix <code>A</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/SCF.jl/blob/d2aedc7280a727405626e2f0ee6ec4d26067e53d/src/gershgorin_discs.jl#L13-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SCF.gershgorin_bounds" href="#SCF.gershgorin_bounds"><code>SCF.gershgorin_bounds</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gershgorin_bounds(A)</code></pre><p>For a Hermitian matrix <code>A</code>, compute the bounds on the real axis of the eigenspectrum. NB that this bound will only be useful for diagonally dominant <code>A</code>s.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaAtoms/SCF.jl/blob/d2aedc7280a727405626e2f0ee6ec4d26067e53d/src/gershgorin_discs.jl#L23-L29">source</a></section><footer><hr/><a class="previous" href="../fock_operators/"><span class="direction">Previous</span><span class="title">Fock Operators</span></a></footer></article></body></html>
